
---------------------------帧差法--------------------------

利用小白点相对背景移动速度快、面积小的特点，比较当前帧与附近的帧之间的灰度差来检测小白点

步骤：
1. 分别与前、后的帧做运算，取两次运算的交集，根据背景的移动最大速度和小白点的最小速度设定合理的帧跨度，使得计算小白点位置的同时，不受背景移动的干扰，得到mask
2. 利用亮度和面积删除mask中白色大面积物体
3. 补洞

优点：
1. 对高速移动的物体效果好，效率高
缺点：
1. 背景移动加快时，若背景上有细小纹理，容易被误检测
2. 有些小白点几乎不动，需要用其他检测算法弥补

待解决的问题：
1. 小鱼刚出来时面积小，被滤除
2. 细小颗粒
3. 背景移动时被检测到

--------------------考虑背景移动的帧差法----------------

利用小白点相对背景移动速度快、面积小的特点，比较当前帧与附近的帧之间的灰度差来检测小白点。考虑背景较为固定的特点，计算出背景的移动速度，减少误检测。

步骤：
1. 利用最大类间方差方法处理当前帧和相邻帧得到背景轮廓
2. 利用连通面积去除背景轮廓中的小白点。
3. 在位移范围内，找到两帧背景重合度最高的情况，根据此时的位移信息移动相邻帧
4. 计算当前帧和移动后的相邻帧的差值，二值化
5. 分别与前、后的帧做步骤1-4运算，取两次运算的交集，根据背景的移动最大速度和小白点的最小速度设定合理的帧跨度，使得计算小白点位置的同时，不受背景移动的干扰，得到mask
6. 利用亮度和面积删除mask中白色大面积物体
7. 补洞

优点：
1. 对高速移动的物体效果好，效率高
2. 对背景只存在整体小范围位移的视频效果好
缺点：
1. 背景移动加快时，若背景上有细小纹理，容易被误检测
2. 有些小白点几乎不动，需要用其他检测算法弥补

待解决的问题：
1. 小鱼刚出来时面积小，被滤除
2. 细小颗粒
3. 背景移动时被检测到


=====================光流法v1========================

---------------光流法v1.1 单stride-------------------

稀疏光流获取背景位移 + 单stride稠密光流找出白点 + hsv过滤 + 前后帧补洞 + 补洞算法补洞 + 物体保护

步骤：

找到需要修复的点：
1. 利用稀疏光流追踪背景的角点（特征是一直慢速），计算出背景的位移
2. 假设当前处理第i帧图像，将第i+stride帧根据背景位移移回原来的位置
3. 将两帧图像用稠密光流算出每个点的位移，距离超过背景位移的视为需要修复的点
4. 用饱和度和亮度配合找到明显且移动缓慢的白点

修复：
1. 利用前后10帧中无需修复的点，根据背景的位移填补当前帧
2. 利用（宽松和严格的）饱和度、明度和大小从原图像中筛选出需要保护的物体（小鱼），从剩余mask中排除掉
3. 剩余待修复的少量区域用补洞算法修复
4. 将小鱼复原

优点：
1. 用前后帧修补图像使得图像连贯性好
2. 对移动的物体效果好，效率高
3. 对背景只存在整体小范围位移的视频效果好
缺点：
1. 有些小白点几乎不动，需要用其他检测算法弥补
2. 背景图像有变形、缩放时修补误差大

待解决的问题：
1. 移速缓慢且不明显的小白点如何去除

---------------光流法v1.2 多stride-------------------

稀疏光流获取背景位移 + 多stride稠密光流找出白点 + 前后帧补洞 + 补洞算法补洞 + 物体保护

步骤：

找到需要修复的点：
1. 利用稀疏光流追踪背景的角点（特征是一直慢速），计算出背景的位移
2. 假设当前处理第i帧图像，将第i+stride帧根据背景位移移回原来的位置
3. 将两帧图像用稠密光流算出每个点的位移，距离超过背景位移的视为需要修复的点mask
4. 将多个stride（如3和30）所生成的mask叠加

修复：
1. 利用前后10帧中无需修复的点，根据背景的位移填补当前帧
2. 利用（宽松和严格的）饱和度、明度和大小从原图像中筛选出需要保护的物体（小鱼），从剩余mask中排除掉
3. 剩余待修复的少量区域用补洞算法修复
4. 复原小鱼

优点：
1. 能捕捉更多缓慢的白点
缺点：
1. 由于第二个步长较大（如30帧），背景缩放不可忽略，导致一些背景一直误判在mask范围内，又因为直接用补洞函数补洞，导致背景被破坏

待解决的问题：
1. 解决背景缩放引起的问题
    解决思路：
    1. 提高阈值(缩放不可忽略，不行)
    2. 修复方法改善为用前后帧平均值修复(好些，指标不治本)
    3. 加入缩放判断(由于角点数量少，在帧跨度小时，偶然误差不可忽略，因此在帧跨度大于10时加入缩放判断)
====================================================

=====================光流法v2.1========================
稀疏光流间接获取帧间位移和缩放 + 多stride稠密光流找出白点 + 前后帧补洞 + 帧平均补洞 + 物体保护

步骤：

找到需要修复的点：
1. 利用稀疏光流追踪背景的角点（特征是一直慢速），计算出相邻帧间的不考虑缩放的位移、考虑缩放的位移、缩放倍数
2. 假设当前处理第i帧图像，stride > 10, 将第i+stride帧根据背景累计位移和累计缩放对齐图像
3. 假设当前处理第i帧图像，stride <= 10, 考虑到缩放的偶然误差，将第i+stride帧根据不考虑缩放的背景累计位移对齐图像
4. 将两帧图像用稠密光流算出每个点的位移，距离超过背景位移的视为需要修复的点mask
5. 将多个stride（如3和30）所生成的mask叠加

修复：
1. 利用前后10帧中无需修复的点，根据背景的位移填补当前帧
2. 利用（宽松和严格的）饱和度、明度和大小从原图像中筛选出需要保护的物体（小鱼），从剩余mask中排除掉
3. 剩余待修复的少量区域用前后帧中去除最高值后的平均值补洞
4. 复原小鱼

优点：
1. 能捕捉更多缓慢的白点
2. 减少了背景的误判
缺点：
1. 尽管去除了最高值，帧平均补洞仍然会残留少量白色拖影
2. 在位移和缩放对齐的过程中，边缘填充的误差会随着帧跨度增加而增加
3. 通过稀疏光流追踪到的角点数量少，难以提取旋转、某一方向上的缩放等变换，能否用其他方式提取特征点
====================================================

=====================光流法v2.2========================
稀疏光流直接获取帧间位移和缩放 + 多stride稠密光流找出白点 + hsv过滤 + 前后帧补洞 + 中值滤波补洞 + 物体保护

步骤：

找到需要修复的点：
1. 利用稀疏光流追踪背景的角点（特征是一直慢速）
2. 假设当前处理第i帧图像，根据第i帧和第i+stride帧的角点计算背景位移和缩放，并对齐位置
3. 将两帧图像用稠密光流算出每个点的位移，距离超过背景位移的视为需要修复的点mask
4. 将多个stride（如3和30）所生成的mask叠加
5. 用饱和度和亮度配合找到明显且移动缓慢的白点

修复：
1. 利用前后10帧中无需修复的点，根据背景的位移填补当前帧
2. 利用（宽松和严格的）饱和度、明度和大小从原图像中筛选出需要保护的物体（小鱼），从剩余mask中排除掉
3. 剩余待修复的少量区域用大小为11的中值滤波补洞
4. 复原小鱼

优点：
1. 优化获取帧间变换的方法
2. 改善了帧平均补洞会残留白色拖影的问题，并提高了补洞效率
缺点：
1. 在位移和缩放对齐的过程中，边缘填充的误差会随着帧跨度增加而增加
2. 通过稀疏光流追踪到的角点数量少，难以提取旋转、某一方向上的缩放等变换，能否用其他方式提取特征点
====================================================

optic v3.1
更新：
1. 系数光流参数
2. 单应性矩阵

optic v3.2
更新：
1. 稀疏光流可以中途加点或去点，以角点的留存时间为依据判断是否为背景角点

=====================光流法v3.3========================
optic v3.3

相较optic v2.2更新：
1. 特征点用orb获取，利用中值滤波、锐化和直方图平均增强抗干扰能力
2. 每一帧都抓取新的特征点，筛选地加入到有效特征点序列中（降低了一些性能）
3. 对齐时，由外沿向内取一定数量的特征点，对齐更准确
4. 由于对齐更准确，制作mask时对对齐距离大的帧下调了阈值
5. 优化前后帧补洞顺序

优点：
1. 特征点更多，允许中途新增的特征点，单应性矩阵对齐，都使画面边缘的物体对齐效果提升明显，减少了背景误判断，边缘物体不再抖动和模糊
2. 白点判断阈值下降，轻微提升了白点检测的能力
缺点：
1. 仍然有剩余的移动缓慢的白点

步骤：

获取背景角点：
1. 对第一帧图像预处理（中值滤波、直方图平均、锐化），并用orb获取特征点
2. 利用稀疏光流追踪上一帧的特征点、根据速度判断有效的点，并记录下来
3. 用orb获取当前帧的特征点，与有效的点一起作为下一帧的稀疏光流的输入
4. 重复2，3步骤
5. 将超速的店、持续时间不够长的点去除
6. 对齐每一帧中对应的特征点，获得背景角点矩阵（每帧可用特征点数量为50-200）

找到需要修复的点：
1. 假设当前处理第i帧图像，找到第i帧和第i+stride帧共有的特征点，用凸包函数取共有特征点外沿的30个点，
2. 计算单应性矩阵，对齐图像
3. 将两帧图像用稠密光流算出每个点的位移，距离超过（0.6 * 背景位移 + 1.8）的视为需要修复的点
4. 将多个stride（如3和30）所生成的mask叠加
5. 用饱和度和亮度配合找到明显且移动缓慢的白点

修复：
1. 利用前后10帧中无需修复的点，对齐填补当前帧
2. 利用（宽松和严格的）饱和度、明度和大小从原图像中筛选出需要保护的物体（小鱼），从剩余mask中排除掉
3. 剩余待修复的少量区域用大小为11的中值滤波补洞
4. 复原小鱼
====================================================
